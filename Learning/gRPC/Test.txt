Types of Cases:
CamelCase: 
Also known as "lower camel case" or "mixed case," where the first letter of each word is capitalized except for the first word, and no spaces or punctuation are used between words. 
From the humps of a camel.
For example: camelCaseExample.

PascalCase: 
Similar to CamelCase, but the first letter of every word is capitalized. PascalCase is often used for naming classes or types in many programming languages. 
In Pascal Programming, it was common to use this casing for naming procedures and functions. As such, it became known as PascalCase.
For example: PascalCaseExample.

Snake Case: 
Words are separated by underscores, and all letters are typically lowercase. 
For example: snake_case_example.


Unit Test:
A unit test is a way of testing a unit,
The smallest piece of code that can be logically isolated in a program.

Naming Convention of file:
1. Snake case
2. Starts with the name of the file in question
3. Ends with "_test.go"
4. main_test.go for main.go


Create a file with a name that ends with _test.go.For example, if we have math.go the unit test file should be math_test.go. And it's also best practice to put the test file and the implementation in the same package.
Create a function in the test file and start the name with Test. The function should take *testing.T from the GoLang testing package. The test function signature is TestXXX(t *testing.T) with XXX as the name of the function we are testing.


We can run the GoLang lang unit test using go test terminal command, Use go test ./... to run all tests within the entire code base. ./... means all files.

Use go test ./... -coverprofile=coverage.out to run the unit test along with generating the unit test coverage profile. We can consume the coverage.out file to display Unit Test Coverage information.


Mocking:
When we write unit tests, we want to test our code in isolation, meaning we focus only on the specific function or method we're testing without worrying about the behavior of any other parts of our code. However, sometimes our function or method depends on other parts of the code, such as calling another function or using a service.
a "mock" is like a stand-in or a fake version of the real thing. It behaves similarly to the real thing but allows us to control its behavior for testing purposes. 
In Java, there are libraries like Mockito that help us create these mocks easily. We can create a mock object that behaves like a real object but is controlled by our test code.
We don't have libraries like Mockito, but we can achieve similar behavior by using interfaces. An interface defines a set of methods that a type must implement. So, instead of directly depending on a concrete implementation of a function or service, we depend on an interface.

----------------------------------------
Convention:
1. Test files should have a name that ends with _test.go.
2. Test functions should begin with the word Test followed by the name of the function being tested.
3. Inside the test file, import the testing package and write test functions with names starting with Test. These functions take a single argument of type *testing.T.
   import "testing"
4. 
---
func TestMyFunction(t *testing.T) {
    // Test logic goes here
}
It means that the test function takes a parameter named t, which is a pointer to a testing.T object. You use this t parameter to communicate with Go's testing framework, reporting test results and controlling test execution.

t: This is just a variable name. You could name it something else if you wanted, but by convention, it's named t in Go test functions.

*: The asterisk (*) before testing.T indicates that t is a pointer to a testing.T object. In Go, passing a pointer allows the function to modify the original object if needed, rather than just working with a copy.

testing.T: This is a type provided by the testing package in Go. It's essentially an interface to interact with the testing framework. You use it to report test failures and control test execution

---
go test -v test_filename :

Go will execute the tests in the current package and display detailed information about each test as it runs, including any log messages generated by the tests
-v stands for "verbose." When you provide this flag, the test output will include additional information, such as the names of tests as they are being run and any logging statements generated by the tests (e.g., those using t.Logf()).

go test -cover test_filename :

This command runs tests and also provides code coverage analysis, showing which parts of your code are covered by tests.

go test -race test_filename :

This command runs tests with the race detector enabled, which helps detect race conditions in concurrent code.


---
