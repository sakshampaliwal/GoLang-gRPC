listener, err := net.Listen("tcp", ":8080")
	if err != nil {
		panic(err)
	}


net.Listen("tcp", ":8080"): indicating that this is a TCP network listener, ":8080" specifies the address and port to listen on.

listener, err := net.Listen("tcp", ":8080"): This line assigns the listener object returned by net.Listen to the variable listener.
If an error occurs during the execution of net.Listen, it will be assigned to the err variable. 
If no error occurs during the execution of net.Listen, the err variable will be nil.
The net.Listen function has a signature like this: func Listen(network, address string) (Listener, error)
It returns two values: a Listener object representing the network listener and an error object representing any error that might have occurred during the execution of the function. thats how err is assigned with an error.

If an error is present, panic(err) will cause the program to terminate immediately and print the error message.


srv := grpc.NewServer()
	pb.RegisterExampleServer(srv, &server{})
	reflection.Register(srv)
	if e := srv.Serve(listener); e != nil {
		panic(e)
	}

srv := grpc.NewServer(): creates a new gRPC server instance named srv. The grpc.NewServer() function returns a new gRPC server object.

pb.RegisterExampleServer(srv, &server{}): 
Registering the server with the gRPC server tells the gRPC server how to link incoming requests to the right functions in your Go code. It's like giving the server a map so it knows which function to call when it receives a specific type of request.
You establish a connection between the methods defined in your gRPC service interface and the corresponding implementation in your Go code.
When a gRPC request arrives at the server, the gRPC server needs to know which method to call to handle that request.
Registration allows the gRPC server to dynamically dispatch incoming RPC calls to the appropriate handler methods in your implementation.


reflection.Register(srv):
Reflection allows clients to explore and understand the services provided by a gRPC server at runtime. Without reflection, clients would need prior knowledge of the server's API, making it harder to interact with.

if e := srv.Serve(listener); e != nil {
    panic(e)
}:
This line starts the gRPC server and makes it listen for incoming connections on the provided listener (listener).

---
func(s *server) ServerReply(c context.Context, req *pb.HelloRequest) (*pb.HelloResponse, error){
	fmt.Println("Receive this request: ", req.SomeString)
	fmt.Println("Hello Saksham")
	return &pb.HelloResponse{}, errors.New("")
}

func (s *server) ServerReply(c context.Context, req *pb.HelloRequest) (*pb.HelloResponse, error) {
: 
(s *server): this function belongs to the server struct. The *server means that s is a pointer to a server struct. This allows the function to access and modify the fields of the server struct.
ServerReply: This is the name of the function.

(c context.Context, req *pb.HelloRequest): Two parameters of a function.

(*pb.HelloResponse, error): This is the return type of the function. It's a tuple indicating that the function returns two values: a pointer to a HelloResponse struct (defined in the pb package), and an error.

---
conn, err := grpc.Dial("localhost:8080", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		panic(err)
	}
	client := pb.NewExampleClient(conn)
	req := &pb.HelloRequest{SomeString: "Hello from client"}
	client.ServerReply(context.TODO(),req)

conn, err := grpc.Dial("localhost:8080", grpc.WithTransportCredentials(insecure.NewCredentials())):

grpc.Dial(): This function is used to establish a connection to a gRPC server. It takes the address of the server to connect to as its first argument.

"localhost:8080": This is the address of the gRPC server we want to connect to. It's specified as "localhost" because the server is running on the same machine,

grpc.WithTransportCredentials(): Transport credentials are used to secure the communication between the client and the server. In this case, it's specifying that we want to use transport credentials, indicating that the communication should be encrypted.
insecure.NewCredentials(): This function creates transport credentials that allow insecure connections. It's used here to indicate that we're not using any form of authentication or encryption for the connection.

client := pb.NewExampleClient(conn)
pb.NewExampleClient is a function auto-generated by gRPC, based on your service definition in the .proto file. It creates a client that corresponds to the gRPC service.

req := &pb.HelloRequest{SomeString: "Hello from client"}:

&pb.HelloRequest{SomeString: "Hello from client"}: This part initializes a new HelloRequest struct and takes its address (& operator), making req a pointer to this struct.

{SomeString: "Hello from client"}: This initializes the fields of the HelloRequest struct. Assuming HelloRequest has a field named SomeString, this line sets its value to "Hello from client".

client.ServerReply(context.TODO(), req):
client: an instance of a gRPC client that has been created earlier in the code. 
client.ServerReply() is a method generated by gRPC based on the service definition. It sends the request to the server's ServerReply method and waits for the response.

The context package in Go is used for carrying deadlines, cancellation signals, Using context.TODO() means there are no specific deadlines or cancellation signals set for this request.
it's just saying, "Here's a blank piece of paper, we don't need anything special right now, just carry on."

req: refers to an instance of a request object that contains data to be sent to the server. This data could include things like parameters, input values, or any other information needed for the server to process the request.

Deadlines: Like setting a timer for how long something can take. If it takes longer than the set time, it's stopped.
Cancellation Signals: Like pressing a stop button on something that's running, telling it to stop gracefully.


---

option go_package = "/gencode"; //is a way to specify where the generated Go code should be placed within your Go project's directory structure.
//This tells the Protocol Buffers compiler to generate Go code in a package named mypackage, and the code will be placed in the appropriate directory structure based on your project's layout.
//you'll find the generated Go code (your_proto_file.pb.go).

/To Run proto file: protoc --go_out=. --go-grpc_out=. your_proto_file.proto
// protoc: This is the Protocol Buffers compiler.
// --go_out=: This flag tells protoc to generate Go code. The = is followed by a directory path (. in this case), specifying where the generated Go code should be saved. In this command, . means the current directory.
// --go-grpc_out=: This flag tells protoc to generate gRPC service code for Go. Similarly, the = is followed by a directory path (. in this case) where the generated gRPC service code should be saved.
// your_proto_file.proto: This is the path to your .proto file. 

---

package package_name;

Consider a scenario where you are developing a microservices-based application, and each microservice communicates with others using gRPC. You may have multiple .proto files, each defining services and message types specific to a particular microservice.

For example, you might have:

user_service.proto: Defines services and message types related to user management.
product_service.proto: Defines services and message types related to product management.
order_service.proto: Defines services and message types related to order management.

Now, you want to ensure that the message types and services defined in these .proto files don't clash with each other. This is where the package statement comes in.

By using the package statement, you can group related protocol buffer definitions together.

user_service.proto is in the users package.
product_service.proto is in the products package.
order_service.proto is in the orders package.

---
Unimplemented Server:
When you're just starting to implement your gRPC service, you can use the Unimplemented*Server structs as placeholders. This allows your server to compile and run, even if you haven't implemented all the RPC methods yet.
Once you've implemented all the RPC methods of your service, you don't need to embed the Unimplemented*Server structs anymore. Instead, you can directly implement the generated server interface.
